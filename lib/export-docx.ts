import {
  Document,
  Paragraph,
  TextRun,
  Table,
  TableRow,
  TableCell,
  WidthType,
  HeadingLevel,
  AlignmentType,
  Packer,
  Header,
  Footer,
  PageNumber,
  TabStopType,
  TabStopPosition,
  BorderStyle,
  ShadingType,
  VerticalAlign,
  TableLayoutType,
} from "docx";
import { saveAs } from "file-saver";

const FIRM_NAME = "NAIR & ASSOCIATES";
const FIRM_TAGLINE = "Advocates & Legal Consultants";
const FIRM_ADDRESS =
  "3rd Floor, Legal Chambers, MG Road, Ernakulam, Kerala - 682011";
const FIRM_CONTACT = "Phone: +91 484 2345678 | Email: office@nairassociates.in";
const BRAND_COLOR = "075E54";
const LIGHT_GREEN = "E8F5E9";
const LIGHT_GRAY = "F5F5F5";

function createHeader(): Header {
  return new Header({
    children: [
      new Paragraph({
        alignment: AlignmentType.CENTER,
        spacing: { after: 40 },
        children: [
          new TextRun({
            text: FIRM_NAME,
            bold: true,
            size: 28,
            color: BRAND_COLOR,
            font: "Georgia",
          }),
        ],
      }),
      new Paragraph({
        alignment: AlignmentType.CENTER,
        spacing: { after: 20 },
        children: [
          new TextRun({
            text: FIRM_TAGLINE,
            italics: true,
            size: 18,
            color: "555555",
            font: "Georgia",
          }),
        ],
      }),
      new Paragraph({
        alignment: AlignmentType.CENTER,
        spacing: { after: 20 },
        children: [
          new TextRun({ text: FIRM_ADDRESS, size: 16, color: "666666" }),
        ],
      }),
      new Paragraph({
        alignment: AlignmentType.CENTER,
        spacing: { after: 60 },
        children: [
          new TextRun({ text: FIRM_CONTACT, size: 16, color: "666666" }),
        ],
      }),
      new Paragraph({
        border: {
          bottom: { style: BorderStyle.SINGLE, size: 6, color: BRAND_COLOR },
        },
        spacing: { after: 200 },
        children: [],
      }),
    ],
  });
}

function createFooter(): Footer {
  return new Footer({
    children: [
      new Paragraph({
        border: {
          top: { style: BorderStyle.SINGLE, size: 4, color: "CCCCCC" },
        },
        spacing: { before: 100, after: 60 },
        children: [],
      }),
      new Paragraph({
        tabStops: [
          { type: TabStopType.CENTER, position: TabStopPosition.MAX / 2 },
          { type: TabStopType.RIGHT, position: TabStopPosition.MAX },
        ],
        children: [
          new TextRun({ text: "Confidential — Nair & Associates", italics: true, size: 14, color: "999999" }),
          new TextRun({ children: ["\t"] }),
          new TextRun({ text: "Generated by LegalDesk AI", italics: true, size: 14, color: "999999" }),
          new TextRun({ children: ["\t"] }),
          new TextRun({ text: "Page ", italics: true, size: 14, color: "999999" }),
          new TextRun({ children: [PageNumber.CURRENT], italics: true, size: 14, color: "999999" }),
          new TextRun({ text: " of ", italics: true, size: 14, color: "999999" }),
          new TextRun({ children: [PageNumber.TOTAL_PAGES], italics: true, size: 14, color: "999999" }),
        ],
      }),
    ],
  });
}

// ── Table border helper ──
const tableBorders = {
  top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
  bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
  left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
  right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
  insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
  insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
} as const;

function createDocxTable(headers: string[], rows: string[][]): Table {
  const headerRow = new TableRow({
    tableHeader: true,
    children: headers.map(
      (h) =>
        new TableCell({
          shading: { type: ShadingType.CLEAR, fill: BRAND_COLOR },
          verticalAlign: VerticalAlign.CENTER,
          margins: { top: 60, bottom: 60, left: 100, right: 100 },
          children: [
            new Paragraph({
              children: parseInlineFormatting(h.trim(), { size: 20, bold: true, color: "FFFFFF" }),
              spacing: { before: 0, after: 0 },
            }),
          ],
        })
    ),
  });

  const dataRows = rows.map(
    (row, ri) =>
      new TableRow({
        children: row.map(
          (cell) =>
            new TableCell({
              shading: ri % 2 === 0
                ? { type: ShadingType.CLEAR, fill: LIGHT_GRAY }
                : { type: ShadingType.CLEAR, fill: "FFFFFF" },
              verticalAlign: VerticalAlign.CENTER,
              margins: { top: 40, bottom: 40, left: 100, right: 100 },
              children: [
                new Paragraph({
                  children: parseInlineFormatting(cell.trim(), { size: 20, color: "333333" }),
                  spacing: { before: 0, after: 0 },
                }),
              ],
            })
        ),
      })
  );

  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    layout: TableLayoutType.AUTOFIT,
    borders: tableBorders,
    rows: [headerRow, ...dataRows],
  });
}

// ── Markdown → DOCX elements (Paragraph | Table) ──
type DocxElement = Paragraph | Table;

function parseMarkdownToElements(text: string): DocxElement[] {
  const lines = text.split("\n");
  const elements: DocxElement[] = [];
  let i = 0;

  while (i < lines.length) {
    const line = lines[i];

    // ── Table detection ──
    if (line.trim().startsWith("|") && i + 1 < lines.length && lines[i + 1]?.match(/^\|[\s-:|]+\|$/)) {
      const parseCells = (l: string) => l.split("|").slice(1, -1).map((c) => c.trim());
      const headers = parseCells(line);
      i += 2; // skip header + separator
      const rows: string[][] = [];
      while (i < lines.length && lines[i].trim().startsWith("|") && !lines[i].match(/^\|[\s-:|]+\|$/)) {
        rows.push(parseCells(lines[i]));
        i++;
      }
      if (headers.length > 0) {
        elements.push(
          new Paragraph({ children: [], spacing: { before: 80, after: 0 } })
        );
        elements.push(createDocxTable(headers, rows));
        elements.push(
          new Paragraph({ children: [], spacing: { before: 0, after: 80 } })
        );
      }
      continue;
    }

    // Skip orphan separator rows
    if (line.match(/^\|[\s-:|]+\|$/)) {
      i++;
      continue;
    }

    // ── Headings ──
    if (line.startsWith("### ")) {
      elements.push(
        new Paragraph({
          heading: HeadingLevel.HEADING_3,
          children: parseInlineFormatting(line.slice(4), { size: 24, bold: true, color: "333333" }),
          spacing: { before: 240, after: 80 },
          border: { bottom: { style: BorderStyle.SINGLE, size: 1, color: "E0E0E0" } },
        })
      );
      i++;
      continue;
    }
    if (line.startsWith("## ")) {
      elements.push(
        new Paragraph({
          heading: HeadingLevel.HEADING_2,
          children: parseInlineFormatting(line.slice(3), { size: 26, bold: true, color: BRAND_COLOR }),
          spacing: { before: 280, after: 100 },
          border: { bottom: { style: BorderStyle.SINGLE, size: 2, color: BRAND_COLOR } },
        })
      );
      i++;
      continue;
    }
    if (line.startsWith("# ")) {
      elements.push(
        new Paragraph({
          heading: HeadingLevel.HEADING_1,
          alignment: AlignmentType.CENTER,
          children: parseInlineFormatting(line.slice(2), { size: 30, bold: true, color: BRAND_COLOR }),
          spacing: { before: 300, after: 120 },
        })
      );
      i++;
      continue;
    }

    // ── Horizontal rule ──
    if (line.match(/^[-*_]{3,}$/)) {
      elements.push(
        new Paragraph({
          border: { bottom: { style: BorderStyle.SINGLE, size: 2, color: "CCCCCC" } },
          spacing: { before: 120, after: 120 },
          children: [],
        })
      );
      i++;
      continue;
    }

    // ── Warning / disclaimer ──
    if (line.includes("⚠️") || (line.startsWith("*") && line.toLowerCase().includes("disclaimer"))) {
      elements.push(
        new Paragraph({
          shading: { type: ShadingType.CLEAR, fill: "FFF8E1" },
          border: {
            left: { style: BorderStyle.SINGLE, size: 8, color: "F9A825" },
            top: { style: BorderStyle.SINGLE, size: 1, color: "FFE082" },
            bottom: { style: BorderStyle.SINGLE, size: 1, color: "FFE082" },
            right: { style: BorderStyle.SINGLE, size: 1, color: "FFE082" },
          },
          indent: { left: 200, right: 200 },
          children: parseInlineFormatting(line, { size: 20, color: "795548" }),
          spacing: { before: 160, after: 160 },
        })
      );
      i++;
      continue;
    }

    // ── Bullet list ──
    if (line.match(/^[\s]*[-•*]\s/)) {
      const content = line.replace(/^[\s]*[-•*]\s/, "");
      elements.push(
        new Paragraph({
          children: parseInlineFormatting(content),
          bullet: { level: 0 },
          spacing: { before: 40, after: 40 },
        })
      );
      i++;
      continue;
    }

    // ── Numbered list ──
    const numMatch = line.match(/^[\s]*(\d+)[.)]\s/);
    if (numMatch) {
      const content = line.replace(/^[\s]*\d+[.)]\s/, "");
      elements.push(
        new Paragraph({
          children: [
            new TextRun({ text: `${numMatch[1]}. `, bold: true, size: 22, color: BRAND_COLOR }),
            ...parseInlineFormatting(content),
          ],
          indent: { left: 360 },
          spacing: { before: 50, after: 50 },
        })
      );
      i++;
      continue;
    }

    // ── Blockquote ──
    if (line.match(/^>\s/)) {
      elements.push(
        new Paragraph({
          border: { left: { style: BorderStyle.SINGLE, size: 6, color: BRAND_COLOR } },
          indent: { left: 300 },
          children: parseInlineFormatting(line.replace(/^>\s/, ""), { size: 22, color: "555555" }),
          spacing: { before: 80, after: 80 },
        })
      );
      i++;
      continue;
    }

    // ── Empty line ──
    if (line.trim() === "") {
      elements.push(
        new Paragraph({ children: [], spacing: { before: 40, after: 40 } })
      );
      i++;
      continue;
    }

    // ── Regular paragraph ──
    elements.push(
      new Paragraph({
        children: parseInlineFormatting(line),
        spacing: { before: 60, after: 60 },
      })
    );
    i++;
  }

  return elements;
}

interface TextStyle {
  size?: number;
  bold?: boolean;
  color?: string;
}

function parseInlineFormatting(text: string, style: TextStyle = {}): TextRun[] {
  const runs: TextRun[] = [];
  const regex = /(\*\*\*(.+?)\*\*\*|\*\*(.+?)\*\*|\*(.+?)\*|`(.+?)`)/g;
  let lastIndex = 0;
  let match;
  const baseSize = style.size || 22;
  const baseColor = style.color || "333333";

  while ((match = regex.exec(text)) !== null) {
    if (match.index > lastIndex) {
      runs.push(
        new TextRun({
          text: text.slice(lastIndex, match.index),
          size: baseSize,
          bold: style.bold,
          color: baseColor,
        })
      );
    }
    if (match[2]) {
      runs.push(
        new TextRun({ text: match[2], bold: true, italics: true, size: baseSize, color: baseColor })
      );
    } else if (match[3]) {
      runs.push(
        new TextRun({ text: match[3], bold: true, size: baseSize, color: BRAND_COLOR })
      );
    } else if (match[4]) {
      runs.push(
        new TextRun({ text: match[4], italics: true, size: baseSize, color: "555555" })
      );
    } else if (match[5]) {
      runs.push(
        new TextRun({ text: match[5], bold: true, size: baseSize - 2, color: BRAND_COLOR, font: "Courier New" })
      );
    }
    lastIndex = match.index + match[0].length;
  }

  if (lastIndex < text.length) {
    runs.push(
      new TextRun({
        text: text.slice(lastIndex),
        size: baseSize,
        bold: style.bold,
        color: baseColor,
      })
    );
  }

  return runs.length > 0
    ? runs
    : [new TextRun({ text, size: baseSize, bold: style.bold, color: baseColor })];
}

export async function exportAsDocx(content: string, filename: string = "document") {
  const elements = parseMarkdownToElements(content);

  const dateParagraph = new Paragraph({
    alignment: AlignmentType.RIGHT,
    spacing: { after: 200 },
    children: [
      new TextRun({
        text: `Date: ${new Date().toLocaleDateString("en-IN", {
          day: "2-digit",
          month: "long",
          year: "numeric",
        })}`,
        size: 20,
        color: "555555",
        italics: true,
      }),
    ],
  });

  const doc = new Document({
    sections: [
      {
        properties: {
          page: {
            margin: { top: 2200, right: 1200, bottom: 1600, left: 1200 },
            pageNumbers: { start: 1 },
          },
        },
        headers: { default: createHeader() },
        footers: { default: createFooter() },
        children: [dateParagraph, ...elements],
      },
    ],
  });

  const blob = await Packer.toBlob(doc);
  saveAs(blob, `${filename}.docx`);
}
